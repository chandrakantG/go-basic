package main

import "fmt"

// Slices are created from arrays and share their data. A slice does not store any data, it just describes a section of an underlying array.
func main() {

	// # syntax or declaration of slice
	// var sliceName []Type
	var emptySl []string // nil slice
	fmt.Println("emptySl:", emptySl)

	// # initialise slice
	// slice literals: which is like an array literal without the length. This creates an array and then builds a slice that references it.
	var veg = []string{"palak", "methi", "ledyfinger"} // declare and initialize value to slice
	fmt.Println("veg:", veg)

	// using make func
	nums := make([]int, 3) // creates a slice with a size of 3, but no values
	fmt.Println("nums:", nums)

	fruits := []string{"apple", "banana", "cherry"} //initializes the fruits slice with three string values
	fmt.Printf("fruits:%v,len:%d,cap:%d \n", fruits, len(fruits), cap(fruits))

	// # Appending To Slices
	fruits = append(fruits, "date") // The append function returns a new slice, so we reassign it to the fruits variable
	fmt.Printf("fruits:%v,len:%d,cap:%d \n", fruits, len(fruits), cap(fruits))

	// # Accessing Slice Elements
	firstFruit := fruits[0] // Accessing the first element
	fmt.Println("firstFruit:", firstFruit)

	// # Slicing a slice
	// create a new slice by referencing a portion of an existing slice
	someFruits := fruits[1:3]
	fmt.Printf("someFruits:%v,len:%d,cap:%d \n", someFruits, len(someFruits), cap(someFruits))
	// We create a new slice someFruits that contains the elements from index 1 to 2 of the fruits slice.
	// The resulting slice will have the values "banana" and "cherry".
	// cap : from index of first element of underlying array of slice to last element of underlying array of slice

	// # Empty And Nil Slices

	// var z []int // nil slice (only declare a slice)
	// fmt.Printf("z:%v,len:%d,cap:%d \n", z, len(z), cap(z))

	y := make([]int, 0) // empty slice(declare and initialise slice with out values)
	// y := []int{} // empty slice
	// var y = []int{} // empty slice
	fmt.Printf("y:%v,len:%d,cap:%d \n", y, len(y), cap(y))

	// In Golang, when a variable is declared without an initialization value, its value will be set to the typeâ€™s zero value.
	// The zero value of a Slice is nil, so in our example below, when we declare var nilSlice []string the value of nilSlice is actually nil not an empty slice of string [].
	// Empty slice can be generated by using Short Variable Declarations eg. foo := []string{} or make function.
	var nilSlice []string
	emptySlice := make([]string, 5)
	fmt.Printf("nilSlice:%v,len:%d,cap:%d \n", nilSlice, len(nilSlice), cap(nilSlice))
	fmt.Println("nilSlice == nil:", nilSlice == nil) // Output: true
	fmt.Printf("emptySlice:%v,len:%d,cap:%d \n", emptySlice, len(emptySlice), cap(emptySlice))
	fmt.Println("emptySlice == nil:", emptySlice == nil) // Output: false

	// 	As you can see there are some similarities between nil and empty slices:

	// Both have zero length and cap
	// Both print []
	// Both can be used the same way in range loops and append functions (not shown here)
	// They differ in the following ways:

	// Only a nil slice will succeed a nil check
	// When encoded as JSON using the standard library, the nil slice becomes null and the empty slice becomes []

	// # Deleting an element from a slice
	mySlice := []int{10, 20, 30, 40}
	mySlice = append(mySlice[:2], mySlice[3:]...) // Go does not have a direct function to delete elements from a slice.

	// # slice use cases:
	// 1. access : mySlice[1]
	// 2. modify : mySlice[1] = 50
	// 3. append : mySlice = append(mySlice,60)
	// 4. delete : mySlice = append(mySlice[:2], mySlice[3:]...)

	// # Slice Capacity And Length
	mySlice = []int{10, 20, 30, 40}
	// * Understanding Length
	// The length of a slice is obtained using the built-in len function.
	// It provides the count of elements present in the slice, which can be iterated over.
	fmt.Println(len(mySlice)) // Output: 4

	// * Understanding Capacity
	// capacity is retrieved using the built-in cap function.
	// It indicates the total number of elements the underlying array of the slice can accommodate,
	// starting from the first element of the slice.
	// or count of index of first element of slice in underlying array to the last index of underlying array
	fmt.Println(cap(mySlice))

	// kindly understand below 2 examples to understand cap
	newSlice := mySlice[:2]                   // slicing the slice
	fmt.Println(len(newSlice), cap(newSlice)) // Output: 2 4

	newSlice1 := mySlice[2:]                    // slicing the slice
	fmt.Println(len(newSlice1), cap(newSlice1)) // Output: 2 2

	// # Slicing The Slice
	// * Basic Slicing
	originalSlice := []int{10, 20, 30, 40, 50}
	newSliceA := originalSlice[1:4]
	fmt.Printf("newSliceA:%v,len:%d,cap:%d \n", newSliceA, len(newSliceA), cap(newSliceA))

	// * omitted indices
	startOmitted := originalSlice[:3] // slicing from start to index 2
	fmt.Printf("startOmitted:%v,len:%d,cap:%d \n", startOmitted, len(startOmitted), cap(startOmitted))
	endOmitted := originalSlice[2:] // slicing from index 2 to end
	fmt.Printf("endOmitted:%v,len:%d,cap:%d \n", endOmitted, len(endOmitted), cap(endOmitted))

	// * Full slice expression
	fmt.Printf("originalSlice:%v,len:%d,cap:%d \n", originalSlice, len(originalSlice), cap(originalSlice))
	fullSlice := originalSlice[1:3:5] // start: 1, end: 3 , capacity(max or end index): 5 (always capacity >= end)
	fmt.Printf("fullSlice:%v,len:%d,cap:%d \n", fullSlice, len(fullSlice), cap(fullSlice))

	// * Impact on original slice
	// new slice references the same array as the original slice, changes to the new slice will affect the original slice and vice versa
	newSliceA[0] = 99 // modifying the new slice
	fmt.Printf("originalSlice:%v,len:%d,cap:%d \n", originalSlice, len(originalSlice), cap(originalSlice))

	// # Common Slice Operations
	// * Appending Elements
	// Appending elements to a slice
	myNewSlice := []int{10, 20}
	fmt.Printf("myNewSlice:%v,len:%d,cap:%d \n", myNewSlice, len(myNewSlice), cap(myNewSlice))
	myNewSlice = append(myNewSlice, 30, 40)
	fmt.Printf("myNewSlice:%v,len:%d,cap:%d \n", myNewSlice, len(myNewSlice), cap(myNewSlice))

	// * Copying Slices
	destSlice := make([]int, 2)
	copy(destSlice, myNewSlice)
	fmt.Printf("destSlice:%v,len:%d,cap:%d \n", destSlice, len(destSlice), cap(destSlice))

	// # Memory Management In Slices

	// * Appending Elements
	// When elements are appended and the slice exceeds its capacity, Go automatically allocates
	// a new array with double the capacity (if the current capacity is less than 1000) and copies the elements over.
	mySliceB := make([]int, 3, 5)
	mySliceB = append(mySliceB, 4, 5, 6)
	fmt.Printf("mySliceB:%v,len:%d,cap:%d \n", mySliceB, len(mySliceB), cap(mySliceB))

	// * Garbage Collection
	// When a slice is no longer needed, it's essential to nil it out to allow Go's garbage collector to reclaim the memory used by the array.
	mySliceB = nil
	fmt.Printf("mySliceB:%v,len:%d,cap:%d \n", mySliceB, len(mySliceB), cap(mySliceB))

	// * Sub-Slicing And Memory
	// Sub-slicing can retain memory even if the original slice is nilled out. It's crucial to create
	// independent slices or use copy to avoid unintentional memory retention.
	// Sub-slicing retaining memory
	subSlice := mySlice[1:3]
	mySlice = nil

	fmt.Printf("subSlice:%v,len:%d,cap:%d \n", subSlice, len(subSlice), cap(subSlice))
	fmt.Printf("mySlice:%v,len:%d,cap:%d \n", mySlice, len(mySlice), cap(mySlice))
}
